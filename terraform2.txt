-> what is terraform and how its work?

Terraform is an Infrastructure as Code (IaC) tool that allows us to provision, configure, and manage infrastructure across multiple 
 cloud providers like AWS, Azure, GCP, and on-prem.

It works in a declarative way:
We define the desired infrastructure in .tf files (e.g., VMs, networks, storage).
Terraform builds a plan by comparing the current state (from the state file + cloud) with the desired state.
On terraform apply, it executes changes to bring real infrastructure in sync with the code.
It maintains a state file to track resources and dependencies.
------------------------------------------------------------------------------------------------------------------------------------------------------------------
-> what is terraform validate? why its used?

"Terraform validate is a CLI command used to check the syntax and correctness of Terraform code without applying it.
 It helps catch errors early, ensures variables and resources are properly defined, 
 and is useful in CI/CD pipelines to prevent invalid configurations from being applied."
 Terraform validate checks for syntax errors like missing curly braces,
  undefined variables, 
  missing required attributes in resources, 
  wrong module paths, and incorrect expressions. 
  It ensures the code is structurally correct before planning or applying changes."
------------------------------------------------------------------------------------------------------------------------------------------------------------------
-> terraform init, plan , apply, destroy?

1. terraform init
Purpose: Initialize a Terraform working directory.
Downloads required providers (like AWS, Azure, GCP).
Initializes the backend for storing the state file.
Must be run once before any other Terraform command.
Example:
terraform init
Output: ‚ÄúTerraform has been successfully initialized!‚Äù
2. terraform plan
Purpose: Preview the changes Terraform will make.
Compares your current state with your configuration files (.tf).
Shows which resources will be created, updated, or destroyed.
No changes are made yet ‚Äî it‚Äôs only a dry run.
Example:
terraform plan
Output:
‚ÄúPlan: 2 to add, 0 to change, 0 to destroy.‚Äù
3. terraform apply
Purpose: Actually apply the planned changes.
Executes the actions shown in the plan.
Creates, modifies, or deletes resources in your cloud provider.
Asks for confirmation before running (unless you use -auto-approve).
Example:
terraform apply
Output:
‚ÄúApply complete! Resources: 2 added, 0 changed, 0 destroyed.‚Äù
4. terraform destroy
Purpose: Remove all resources managed by Terraform.
Destroys all infrastructure defined in your .tf files.
Useful for cleaning up environments (e.g., dev or test).
Example:
terraform destroy
Output:
‚ÄúDestroy complete! Resources: 2 destroyed.‚Äù
------------------------------------------------------------------------------------------------------------------------------------------------------------------
-> in your organization which terraform version your using currently?

In our organization, we‚Äôre currently using Terraform v1.5.x (or v1.6.x), since it‚Äôs stable and compatible with our existing modules and providers. We regularly test new versions in a staging environment before upgrading, to ensure backward compatibility and avoid breaking changes.‚Äù
------------------------------------------------------------------------------------------------------------------------------------------------------------------
-> what are the variables, types of variables and how do you pass variable in run time in terraform? 

Variables in Terraform are used to make configurations dynamic and reusable.
Instead of hardcoding values (like instance types or region), you define them as variables and assign values separately.
Types of Variables
-- String ‚Äì Single text value
variable "region" {
  type    = string
  default = "us-east-1"
}
-- Number ‚Äì Numeric value
variable "instance_count" {
  type    = number
  default = 2
}
-- Bool ‚Äì True or false
variable "enable_monitoring" {
  type    = bool
  default = true
}
-- List ‚Äì Ordered list of values
variable "azs" {
  type    = list(string)
  default = ["us-east-1a", "us-east-1b"]
}
-- Map ‚Äì Key-value pairs
variable "tags" {
  type = map(string)
  default = {
    Environment = "dev"
    Owner       = "teamA"
  }
}

Ways to Pass Variables at Runtime
You can pass variables in four main ways:
Using -var option (CLI):
terraform apply -var="region=us-west-2"
Using .tfvars file:
region = "us-west-2"
instance_count = 3
Run with:
terraform apply -var-file="dev.tfvars"
Using Environment Variables:
export TF_VAR_region="us-west-2"
terraform apply
Using Default Values:
If a variable has a default, Terraform uses it automatically.
variable "instance_type" {
  type    = string
  default = "t2.small"
}
------------------------------------------------------------------------------------------------------------------------------------------------------------------
-> remote backend in terraform?

A backend in Terraform determines where the state file is stored.
By default, Terraform uses a local backend (state file stored locally).
A remote backend stores the state in a centralized location, which is important for team collaboration and security.
Benefits of Remote Backend
Collaboration: Multiple team members can work on the same infrastructure safely.
State Locking: State locking stops multiple updates at once.
Versioning: Versioning keeps history so you can restore old state files.
Security: State files can contain sensitive data; remote backends often support encryption.

For Azure Example
terraform {
  backend "azurerm" {
    resource_group_name  = "rg-terraform"
    storage_account_name = "terraformstate123"
    container_name       = "tfstate"
    key                  = "dev.terraform.tfstate"
  }
}
------------------------------------------------------------------------------------------------------------------------------------------------------------------
-> what are the modules, why we are using it and different kinds of modules in terraform?

A module in Terraform is a container for multiple resources that are used together.
It‚Äôs like a reusable block of code ‚Äî instead of writing the same resource code again and again, you define it once as a module and use it wherever needed.
Why We Use Modules
Reusability ‚Äì Use the same infrastructure code for multiple environments (dev, test, prod).
Organization ‚Äì Keep Terraform code clean and modular instead of one big file.
Consistency ‚Äì Apply standard infrastructure patterns across teams.
Scalability ‚Äì Makes managing large infrastructures easier.
Types of Modules in Terraform
| Type                     | Description                                                                                 |
| ------------------------ | ------------------------------------------------------------------------------------------- |
| **Root Module**          | The main working directory that contains `.tf` files you run (`terraform apply` on).        |
| **Child Module**         | Called from within another module or root module using the `module` block.                  |
| **Public Module**        | Modules available from the **Terraform Registry** (like ready-made AWS VPC or EC2 modules). |
| **Private/Local Module** | Custom modules stored in your local repo or private registry for internal use.              |

main.tf:
# Create Resource Group
module "rg" {
  source              = "./modules/resource_group"
  resource_group_name = "app-rg"
  location            = "East US"
}

# Create Virtual Network
module "vnet" {
  source              = "./modules/vnet"
  vnet_name           = "app-vnet"
  address_space       = ["10.0.0.0/16"]
  location            = module.rg.location
  resource_group_name = module.rg.name
}

# Create Virtual Machine
module "vm" {
  source              = "./modules/vm"
  vm_name             = "app-vm"
  location            = module.rg.location
  resource_group_name = module.rg.name
  subnet_id           = module.vnet.subnet_id
  admin_username      = "azureuser"
  admin_password      = "Password@123"
}

modules/resource_group/main.tf:

resource "azurerm_resource_group" "rg" {
  name     = var.resource_group_name
  location = var.location
}

output "name" {
  value = azurerm_resource_group.rg.name
}

output "location" {
  value = azurerm_resource_group.rg.location
}
------------------------------------------------------------------------------------------------------------------------------------------------------------------
-> we deleted the state file what will happened we again do terraform plan , apply?

The Terraform state file (terraform.tfstate) keeps a record of what resources already exist in your cloud.
If you delete it, Terraform forgets everything it previously created.
Now, if you run terraform plan after deleting the state file:
Terraform no longer knows any existing resources.
So it will compare your configuration with an empty state and think:
‚ÄúNo resources exist ‚Äî I need to create them all again.‚Äù
Output:
Plan: 3 to add, 0 to change, 0 to destroy.
Even though your infrastructure already exists in Azure/AWS, Terraform doesn‚Äôt realize that ‚Äî it wants to recreate everything.
If you then run terraform apply:
Terraform will try to create all those resources again, which can cause:
Duplicate resources (like another VM or VNet with the same name)
Errors (if resource names must be unique)
Loss of previous tracking (Terraform no longer manages your old resources)
How to Fix (Best Practice)
If you accidentally delete the state file but your infrastructure still exists:
Use
terraform import <resource_address> <resource_id>
to re-import existing resources into a new state file.
Example:
terraform import azurerm_resource_group.rg /subscriptions/<id>/resourceGroups/my-rg
Or restore the state file from your remote backend backup (e.g., S3 versioning, Terraform Cloud).
------------------------------------------------------------------------------------------------------------------------------------------------------------------
-> Can you destroy only one resource in Terraform? If yes, how?

Yes, we can destroy a single specific resource in Terraform using the -target flag with the terraform destroy command.
For example, if I have a resource like this:
resource "azurerm_storage_account" "storage" {
  name                     = "mystorage12345"
  resource_group_name      = azurerm_resource_group.rg.name
  location                 = azurerm_resource_group.rg.location
  account_tier             = "Standard"
  account_replication_type = "LRS"
}
and I only want to delete the storage account ‚Äî not the resource group ‚Äî
I‚Äôll run this command:
terraform destroy -target=azurerm_storage_account.storage
This will plan and destroy only that specific resource without affecting others.
However, I‚Äôll also mention that the -target option should be used carefully ‚Äî it‚Äôs mainly for testing or selective clean-up, not regular use, because it can lead to inconsistent states if dependencies exist.
------------------------------------------------------------------------------------------------------------------------------------------------------------------
-> what is lifecycle block in terraform? when we are using it?

The lifecycle block in Terraform is used inside a resource to control how Terraform creates, updates, or destroys that resource.
resource "azurerm_storage_account" "example" {
  name                     = "mystorage12345"
  resource_group_name      = azurerm_resource_group.rg.name
  location                 = "East US"
  account_tier             = "Standard"
  account_replication_type = "LRS"

  lifecycle {
    prevent_destroy = true
    ignore_changes  = [tags]
    create_before_destroy = true
  }
}

| Argument                  | Description                                                                                                |
| ------------------------- | ---------------------------------------------------------------------------------------------------------- |
| **prevent_destroy**       | Prevents Terraform from accidentally deleting the resource. Helpful for critical resources like databases. |
| **ignore_changes**        | Ignores specific attribute updates so Terraform doesn‚Äôt trigger an unnecessary change.                     |
| **create_before_destroy** | Creates a new resource first before destroying the old one (helps avoid downtime).                         |

When Do We Use It?

When we want to protect critical resources from deletion (prevent_destroy).
When changes made outside Terraform should be ignored (ignore_changes).[manually updating tags, sizes etc]
When we need zero downtime during updates (create_before_destroy).

------------------------------------------------------------------------------------------------------------------------------------------------------------------
-> What is taint and untaint in Terraform? When do we use them?

In Terraform, taint and untaint are used to manually mark resources for recreation.
They help when a resource is not behaving correctly or has gone out of sync with its state, but Terraform itself doesn‚Äôt detect any change.

| Command                            | Purpose                                                                                           |
| ---------------------------------- | ------------------------------------------------------------------------------------------------- |
| **`terraform taint <resource>`**   | Marks a resource as *tainted*, so Terraform will **destroy and recreate** it in the next `apply`. |
| **`terraform untaint <resource>`** | Removes the taint mark, meaning Terraform will **not recreate** the resource on the next apply.   |

resource "azurerm_linux_virtual_machine" "example" {
  name                = "app-server"
  resource_group_name = azurerm_resource_group.rg.name
  location            = "East US"
  size                = "Standard_B1s"
  admin_username      = "azureuser"
  admin_password      = "P@ssword1234!"
}
Now imagine your VM is running, but some internal configuration is broken (for example, a failed script, or corrupted OS), and you want Terraform to recreate it ‚Äî even though no code changes were made.

You can mark it tainted manually:
terraform taint azurerm_linux_virtual_machine.example
Then run:
terraform apply
Terraform will now destroy and recreate that VM ‚Äî fixing it without you changing the .tf code.
When to Use taint:
When a resource is corrupted or not functioning properly in real environment.
When manual changes made outside Terraform cause inconsistencies.
When you want to force recreation for troubleshooting or testing.
When Terraform state shows resource as healthy, but it‚Äôs actually broken.
When to Use untaint:
If you tainted a resource by mistake, use:
terraform untaint azurerm_linux_virtual_machine.example
Now the resource will not be destroyed in the next apply.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
-> You are managing a complex infrastructure with multiple components, and you need to ensure that Terraform deploys 
all resources in the correct order?

In Terraform, the depends_on argument is used to explicitly define a dependency between resources.
It ensures that one resource is created or destroyed only after another specific resource has been created or destroyed ‚Äî
 even if there‚Äôs no direct reference between them.

Example:
resource "azurerm_resource_group" "rg" {
  name     = "my-rg"
  location = "East US"
}

resource "azurerm_network_security_group" "nsg" {
  name                = "my-nsg"
  location            = azurerm_resource_group.rg.location
  resource_group_name = azurerm_resource_group.rg.name
}

resource "azurerm_network_interface" "nic" {
  name                = "my-nic"
  location            = azurerm_resource_group.rg.location
  resource_group_name = azurerm_resource_group.rg.name

  ip_configuration {
    name                          = "internal"
    subnet_id                     = azurerm_subnet.subnet.id
    private_ip_address_allocation = "Dynamic"
  }
}

# üëá Example of depends_on
resource "azurerm_linux_virtual_machine" "vm" {
  name                  = "my-vm"
  location              = azurerm_resource_group.rg.location
  resource_group_name   = azurerm_resource_group.rg.name
  size                  = "Standard_B1s"
  admin_username        = "azureuser"
  admin_password        = "P@ssword1234!"
  network_interface_ids = [azurerm_network_interface.nic.id]

  # üëá Explicit dependency
  depends_on = [
    azurerm_network_security_group.nsg,
    azurerm_network_interface.nic
  ]
}

------------------------------------------------------------------------------------------------------------------------------------------------------------------
--> You want to create an instance (AWS EC2 / Azure VM) using Terraform and then execute a shell script on the instance after 
it has been created. How can you achieve this?

‚ÄúWe can achieve this using the provisioner block in Terraform.
The remote-exec provisioner allows us to run shell commands or scripts on the instance after it‚Äôs created, and the file provisioner 
is used to upload files to the VM before running them.‚Äù

file ‚Äì to upload a file from local to the instance.
remote-exec ‚Äì to run commands or shell scripts inside the remote instance.
local-exec ‚Äì to run commands locally on the machine where Terraform is executed (like triggering Ansible or scripts).

*** Using custom_data (Recommended)
You can pass your shell script using the custom_data field (it runs on first boot).

resource "azurerm_linux_virtual_machine" "example" {
  name                  = "my-vm"
  resource_group_name   = azurerm_resource_group.rg.name
  location              = azurerm_resource_group.rg.location
  size                  = "Standard_B1s"
  admin_username        = "azureuser"
  admin_password        = "P@ssword1234!"
  network_interface_ids = [azurerm_network_interface.nic.id]

  os_disk {
    caching              = "ReadWrite"
    storage_account_type = "Standard_LRS"
  }

  # üëá Run a shell script on creation
  custom_data = filebase64("init-script.sh")
}
Where init-script.sh contains:
#!/bin/bash
sudo apt update -y
sudo apt install nginx -y
sudo systemctl start nginx

# remote and local exec
provider "azurerm" {
  features {}
}

resource "azurerm_resource_group" "rg" {
  name     = "example-rg"
  location = "East US"
}

resource "azurerm_linux_virtual_machine" "vm" {
  name                  = "demo-vm"
  resource_group_name   = azurerm_resource_group.rg.name
  location              = azurerm_resource_group.rg.location
  size                  = "Standard_B1s"
  admin_username        = "azureuser"
  admin_password        = "P@ssword1234!"
  network_interface_ids = []

  os_disk {
    caching              = "ReadWrite"
    storage_account_type = "Standard_LRS"
  }

  # üëâ Run command inside VM after creation
  provisioner "remote-exec" {
    inline = [
      "sudo apt update -y",
      "sudo apt install -y nginx",
      "echo 'Nginx installed successfully' > /tmp/status.txt"
    ]

    connection {
      type     = "ssh"
      user     = "azureuser"
      password = "P@ssword1234!"
      host     = self.public_ip_address
    }
  }

  # üëâ Run command locally on your Terraform host
  provisioner "local-exec" {
    command = "echo VM ${self.name} created successfully >> output.log"
  }
}


------------------------------------------------------------------------------------------------------------------------------------------------------------------
--> You have an existing infrastructure on AWS/azure, and you need to use Terraform to manage it. How would you import these 
resources into your Terraform configuration?

‚ÄúWe can use the terraform import command to bring existing resources into Terraform state so Terraform can start managing them.
First, we define the same resource block in our Terraform code, then use the import command to link that existing AWS resource 
to Terraform‚Äôs state file.‚Äù

Example (AWS):
resource "aws_instance" "web" {
  ami           = "ami-0c55b159cbfafe1f0"
  instance_type = "t2.micro"
}


Then import the existing EC2 instance using its resource ID:

terraform import aws_instance.web i-0abcd1234ef567890


Terraform then maps that real AWS instance to your Terraform configuration.

Example (Azure):
resource "azurerm_resource_group" "rg" {
  name     = "my-rg"
  location = "East US"
}


Then import it using:

terraform import azurerm_resource_group.rg /subscriptions/xxxx/resourceGroups/my-rg
--------------------------------------------------------------------------------------------------------------------------------------------------
-->  You are working with multiple environments (e.g., dev, prod) and want to avoid duplicating code. 
How would you structure your Terraform configurations to achieve code reuse?

‚ÄúTo avoid duplicating code across environments, I use Terraform modules.
I‚Äôll create a common reusable module for resources like VMs, networks, or storage, and then call that module separately 
for each environment ‚Äî dev, test, or prod ‚Äî by passing different variables.
This helps in maintaining consistency and makes code easy to manage.‚Äù
module "compute" {
  source     = "../../modules/compute"
  vm_name    = "dev-vm"
  vm_size    = "Standard_B1s"
  environment = "dev"
}
---------------------------------------------------------------------------------------------------------------------------------------------------
-->  Describe a situation where you might need to use the terraform remote backend, and what advantages does it offer in state management?

We use a remote backend when multiple team members are managing the same Terraform project.
It stores the Terraform state file in a remote location like AWS S3 or Azure Storage Account instead of locally.
This helps in team collaboration, state locking, version control, and also prevents accidental deletion or corruption of the local state file.‚Äù

-------------------------------------------------------------------------------------------------------------------------------------------------
--> Your team is adopting a multi-cloud strategy, and you need to manage resources on both AWS and Azure using Terraform. 
How would you structure your Terraform code to handle this?

For a multi-cloud setup, I use separate provider blocks for AWS and Azure, and organize my Terraform code using modules and environment folders.
Each cloud will have its own module (like AWS-network, Azure-network, etc.), and then I call them from a common root module or environment-specific folder.
This way, we can manage both clouds with the same Terraform workflow but keep their configurations isolated.‚Äù
Why this structure?
Isolation: Keeps AWS and Azure code separate and easy to maintain.
Reusability: Modules can be reused across environments.
Scalability: Easy to add new clouds later.
Separation of state: Each provider can have its own backend (e.g., S3 for AWS, Azure Storage for Azure).
--------------------------------------------------------------------------------------------------------------------------------------------------

--> You are dealing with sensitive information, such as API keys, in your Terraform configuration. What approach would you take to manage these securely?

In Terraform, I never hardcode sensitive values like API keys or passwords in the configuration files.
I store them securely in secret management services such as AWS Secrets Manager or Azure Key Vault, and then fetch them dynamically during Terraform execution.
This prevents secrets from being exposed in code or state files.‚Äù

Other Best Practices to Mention:
Use Terraform variables with sensitive = true to hide output values.
Store variables in .tfvars or environment variables, not in main.tf.
Use remote backends (S3/Azure Storage) with encryption enabled.
Never commit secrets to version control (use .gitignore).

---------------------------------------------------------------------------------------------------------------------------------------------------
--> Describe a scenario where you might need to use Terraform workspaces, and how would you structure your project to take advantage of them?

‚ÄúWe use Terraform workspaces when we want to manage multiple environments (like dev, test, and prod) using the same codebase, but with separate state files.
Each workspace maintains its own isolated state, so changes in one environment don‚Äôt affect others.‚Äù

Advantages:
No need to duplicate code for multiple environments.
Each environment has an isolated state file.
Easy to switch between environments with one command.
Perfect for smaller teams or simple multi-env setups.
-------------------------------------------------------------------------------------------------------------------------------------------------------------
--> You've made changes to your Terraform configuration, and now you want to preview the execution plan before applying the changes. How would you do this?

‚ÄúIn Terraform, before applying any changes, I use the terraform plan command to preview what actions Terraform will take ‚Äî like what resources will be created, updated, or destroyed.
It helps to verify the configuration and avoid unexpected changes before applying.‚Äù

Example Command:
terraform plan
To save the plan to a file (for approval or CI/CD):
terraform plan -out=tfplan

To apply that saved plan later:
terraform apply tfplan
Why We Use It:
To preview infrastructure changes safely.
To validate before applying in production.
To share the plan file in team approvals or pipelines.
---------------------------------------------------------------------------------------------------------------------------------------------------------
--> Your team has decided to adopt GitOps practices for managing infrastructure with Terraform. How would you integrate Terraform 
with version control systems like Git?

‚ÄúIn a GitOps setup, we integrate Terraform with Git by storing all Terraform configuration files (.tf) in a Git repository.
Any change to the infrastructure goes through pull requests, which are reviewed and approved before being merged.
Once merged, a CI/CD pipeline (like GitHub Actions, Azure DevOps, or Jenkins) automatically runs terraform init, terraform plan, and terraform apply to deploy the infrastructure.‚Äù

Example Workflow:

Developer creates a feature branch and updates Terraform code.

Runs locally:

terraform fmt
terraform validate
terraform plan


Opens a Pull Request (PR) for review.

When PR is merged to main, a pipeline triggers automatically:

terraform init
terraform plan -out=tfplan
terraform apply -auto-approve tfplan
--------------------------------------------------------------------------------------------------------------------------------------------------
--> Terraform vault?

Terraform Vault refers to HashiCorp Vault, a secret management tool developed by the same company that made Terraform.
It helps to store, generate, and manage secrets dynamically and securely, like database passwords, API tokens, or cloud credentials.
Terraform integrates with Vault through the Vault provider, allowing Terraform to fetch or generate secrets at 
runtime instead of hardcoding them.
When Do We Use Vault?

You use Vault when:
You need to manage secrets across multiple clouds (AWS, Azure, GCP).
You want dynamic secrets (temporary credentials that expire automatically).
You need centralized, fine-grained access control for secrets.
Your organization prefers an on-prem or hybrid security model, not tied to one cloud.

| Feature             | **HashiCorp Vault**                                      | **AWS Secrets Manager**        | **Azure Key Vault**   |
| ------------------- | -------------------------------------------------------- | ------------------------------ | --------------------- |
| **Scope**           | Multi-cloud & On-prem                                    | AWS only                       | Azure only            |
| **Secret Types**    | Static & Dynamic (temporary creds)                       | Static                         | Static                |
| **Integration**     | Works with Terraform, Ansible, Jenkins, Kubernetes, etc. | AWS-specific                   | Azure-specific        |
| **Access Control**  | Detailed, policy-based ACL                               | IAM roles/policies             | RBAC                  |
| **Secret Rotation** | Automatic, customizable                                  | Automatic for limited services | Manual or event-based |
| **Dynamic Secrets** | ‚úÖ Yes (DB creds, AWS tokens, etc.)                       | ‚ùå No                           | ‚ùå No                  |

provider "vault" {
  address = "https://vault.company.com"
  token   = var.vault_token
}

# Reading secret from Vault
data "vault_generic_secret" "db_creds" {
  path = "secret/data/db"
}

resource "aws_db_instance" "example" {
  engine     = "mysql"
  username   = data.vault_generic_secret.db_creds.data["username"]
  password   = data.vault_generic_secret.db_creds.data["password"]
}
------------------------------------------------------------------------------------------------------------------------------------------------------
--> Your team wants to ensure that the infrastructure is consistently provisioned across multiple environments. 
How would you implement a consistent environment configuration?

workspace, modules, variables
---------------------------------------------------------------------------------------------------------------------------------------------------
--> You are tasked with migrating your existing infrastructure from Terraform v0.11 to v0.12. What considerations and steps would you take?

‚ÄúWhen upgrading from Terraform v0.11 to v0.12, I first review the Terraform upgrade guides because v0.12 introduced major 
syntax and language improvements, like first-class expressions, for loops, and better type handling.
I take a backup of the state file, update Terraform to v0.12, and then use the terraform 0.12upgrade command to automatically 
rewrite and validate the configurations.‚Äù

Step-by-Step Migration Process:

Backup Everything
Take backups of all .tf files and the current terraform.tfstate file.
Example:
cp terraform.tfstate terraform.tfstate.backup
Install Terraform v0.12
Update Terraform to version 0.12 on your system or CI/CD pipeline.
Run the Upgrade Tool
Terraform provides a built-in helper:
terraform 0.12upgrade
This command scans all .tf files and updates deprecated syntax (like interpolation, variable usage, etc.).

Validate the Configuration
terraform validate
Run Plan and Compare
terraform plan
terraform apply
-----------------------------------------------------------------------------------------------------------------------------------------------------
-> You need to create multiple instances of the same resource with slightly different configurations.
How can you accomplish this efficiently in Terraform?

In Terraform, I can efficiently create multiple instances of the same resource using meta-arguments like count and for_each.
If I want to create identical resources, I use count, which repeats the same configuration multiple times.
But when each resource needs slightly different configurations, I prefer for_each, since it lets me define unique values for each instance using a map or set.

variable "vms" {
  type = map(any)
  default = {
    vm1 = { size = "Standard_B1s", location = "East US" }
    vm2 = { size = "Standard_B2s", location = "West US" }
  }
}

resource "azurerm_linux_virtual_machine" "example" {
  for_each            = var.vms
  name                = each.key
  location            = each.value.location
  resource_group_name = azurerm_resource_group.rg.name
  size                = each.value.size
  admin_username      = "azureuser"
  admin_password      = "P@ssword1234!"
  network_interface_ids = []
}

count
variable "environments" {
  default = ["dev", "qa", "prod"]
}

resource "azurerm_resource_group" "rg" {
  count    = length(var.environments)
  name     = "rg-${var.environments[count.index]}"
  location = "East US"
}
------------------------------------------------------------------------------------------------------------------------------------------------------------
-> What is the difference between count and for_each in Terraform? When do you use them and why?

| Feature / Criteria      | **`count`**                                                          | **`for_each`**                                                        |
| ----------------------- | -------------------------------------------------------------------- | --------------------------------------------------------------------- |
| **Purpose**             | Used to create **multiple identical resources**.                     | Used to create **multiple resources with different configurations**.  |
| **Input Type**          | Accepts a **number** or **list**.                                    | Accepts a **map** or **set**.                                         |
| **Access Syntax**       | Access elements using **`count.index`**.                             | Access elements using **`each.key`** and **`each.value`**.            |
| **Best for**            | When all resources are similar and differ only by index or name.     | When each resource has unique attributes (like size, region, etc.).   |
| **Example Use Case**    | Creating 3 identical subnets or resource groups.                     | Creating multiple VMs with different sizes or locations.              |
| **Flexibility**         | Less flexible ‚Äî cannot easily modify or remove specific items.       | More flexible ‚Äî can target individual items by key.                   |
| **Resource Addressing** | Changes in the list can cause **resource recreation** (index-based). | Stable addressing ‚Äî changes don‚Äôt affect other resources (key-based). |
| **Performance Impact**  | Slightly simpler and faster for identical resources.                 | Slightly more complex but better for variable configurations.         |
| **Syntax Example**      | `count = 3`                                                          | `for_each = var.vms`                                                  |
---------------------------------------------------------------------------------------------------------------------------------------------------------------
-> You have a Terraform configuration that creates multiple resources in a specific order, but you need to skip one specific resource in the sequence. How can you accomplish this in Terraform?

In Terraform, we can conditionally skip creating a specific resource using the count or for_each argument combined with a conditional expression.
Instead of commenting or deleting the resource, we control whether it gets created by setting the count to 0 (which means skip creation).

variable "envs" {
  default = ["dev", "test", "prod"]
}

resource "azurerm_resource_group" "example" {
  count    = length(var.envs)
  name     = "${var.envs[count.index]}-rg"
  location = "East US"

  # Skip creating 'test' environment
  lifecycle {
    prevent_destroy = false
  }

  # Conditional creation logic
  count = var.envs[count.index] == "test" ? 0 : 1
}
# for each
variable "envs" {
  default = {
    dev  = true
    test = false
    prod = true
  }
}

resource "azurerm_resource_group" "example" {
  for_each = { for k, v in var.envs : k => v if v }

  name     = "${each.key}-rg"
  location = "East US"
}
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
-> You want to deploy a Virtual Machine (VM) in a specific availability zone,
but you are not sure which zone to use.
How can you dynamically select it at runtime in Terraform?

‚ÄúIn Terraform, I can dynamically select an availability zone at runtime by using data sources like data.azurerm_zones (Azure) or data.aws_availability_zones.
I can then use functions like element() or resources like random_shuffle to pick one zone automatically.
This ensures that my deployment is dynamic and doesn‚Äôt depend on hardcoded zone values.‚Äù

# Fetch available zones dynamically
data "azurerm_subnet" "example" {
  name                 = "subnet1"
  virtual_network_name = "vnet-demo"
  resource_group_name  = "rg-demo"
}

# Fetch the available zones from Azure region
data "azurerm_zones" "available" {
  location = "East US"
}
Step	Description
data "azurerm_zones"	Fetches the available zones in the given region (East US).
element()	Picks one element (e.g., first zone) from that list.
zone = ...	Dynamically assigns that zone to your VM.

data "azurerm_zones" "available" {
  location = "East US"
}

resource "random_shuffle" "zone" {
  input        = data.azurerm_zones.available.names
  result_count = 1
}

-----------------------------------------------------------------------------------------------------------------------------------------------------------------
-> You have a Terraform configuration that creates a VM with a public IP,
and you need to restrict access to it using a Network Security Group (NSG).How would you accomplish that in Terraform?

‚ÄúI would create a Network Security Group (NSG) with specific inbound rules ‚Äî for example, allowing SSH only from my office IP ‚Äî and then associate that NSG with the VM‚Äôs network interface.
This way, even though the VM has a public IP, its access is restricted and secured by the NSG.‚Äù
------------------------------------------------------------------------------------------------------------------------------------------------------------------
-> How do you handle errors in Terraform during plan, apply, or destroy operations?
I handle Terraform errors through multiple layers ‚Äî
I use variable validation to prevent bad input, conditional logic to skip invalid configurations,
lifecycle rules to protect critical resources, and functions like try() and can() to handle runtime errors gracefully.
Additionally, I always run terraform plan before apply to catch errors early and use remote state + proper dependencies to avoid race conditions.‚Äù
Input Validation ‚Äì Validate variable values to prevent invalid inputs before execution.
Conditional Logic ‚Äì Use conditions to skip or control resource creation dynamically.
Lifecycle Rules ‚Äì Protect critical resources from accidental deletion or modification.
Plan and Review ‚Äì Always run terraform plan before apply to catch errors early.
try() / can() Functions ‚Äì Gracefully handle runtime errors or missing values.
depends_on ‚Äì Ensure correct resource creation order to avoid dependency errors.
State Management ‚Äì Use Terraform state commands to fix or recover from failed applies.

------------------------------------------------------------------------------------------------------------------------------------------------------------------
-> What are workspaces in Terraform? Why and when do you use them?

‚ÄúIn Terraform, workspaces are used to manage multiple environments (like dev, test, and prod) using the same configuration files but with separate state files.‚Äù
Each workspace has its own Terraform state file.
This allows you to reuse the same code for different environments without overwriting each other‚Äôs state.
For example, one workspace can manage Dev resources, and another can manage Prod ‚Äî all from the same configuration.
terraform workspace new dev
terraform workspace new prod
terraform workspace select dev
terraform apply   # applies to dev state
terraform workspace select prod
terraform apply   # applies to prod state
| Use Case                                      | Why Use Workspace                                       |
| --------------------------------------------- | ------------------------------------------------------- |
| Multiple environments (dev, test, prod)       | To isolate states within the same codebase              |
| Feature or branch testing                     | To safely test new changes without affecting main infra |
| Managing identical infra in different regions | Each workspace can represent one region                 |
----------------------------------------------------------------------------------------------------------------------------------------------------------------
